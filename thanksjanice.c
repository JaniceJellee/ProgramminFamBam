#pragma config(Motor,  port2,           TLMot,         tmotorVex393, openLoop)
#pragma config(Motor,  port3,           TRMot,         tmotorVex393, openLoop)
#pragma config(Motor,  port4,           BRMot,         tmotorVex393, openLoop)
#pragma config(Motor,  port5,           BLMot,         tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int STOP = 0;
const int THRESH = 32;
bool tankDrive = true;
bool twoJoyStr = true;
float SCLR = 1.0;

void LMot(int LPow)
{
	motor[TLMot] = LPow;
	motor[BLMot] = LPow;
}

void RMot(int RPow)
{
	motor[TRMot] = RPow;
	motor[BRMot] = RPow;
}

void tankFunc(int LPow, int RPow)
{
	if((abs(LPow) > THRESH)||(abs(RPow) > THRESH))
	{
		LMot(LPow);
		RMot(RPow);
	}
	else
	{
		LMot(STOP);
		RMot(STOP);
	}
}

void steerDrive(int STRPow, int TVPow)
{
	if((abs(TVPow) > THRESH)||(abs(STRPow) > THRESH))
	{
		if((abs(TVPow + STRPow) > 128)||(abs(TVPow - STRPow) > 128))
		{
			SCLR = 0.5;
		}
		else
		{
			SCLR = 1.0;
		}
		LMot(SCLR * (float)(TVPow + STRPow));
		RMot(SCLR * (float)(TVPow - STRPow));
	}
	else
	{
		LMot(STOP);
		RMot(STOP);
	}
}

task DriveControl()
{
	while(true)
	{
		if(vexRT[Btn6U] == 1)
		{
			tankDrive = true;
		}
		else if(vexRT[Btn6D] == 1)
		{
			tankDrive = false;
		}
		if(vexRT[Btn5U] == 1)
		{
			twoJoyStr = true;
		}
		else if(vexRT[Btn5D] == 1)
		{
			twoJoyStr = false;
		}
		if(tankDrive)
		{
			tankFunc(vexRT[Ch3], vexRT[Ch2]);
		}
		else
		{
			if(twoJoyStr)
			{
				steerDrive(vexRT[Ch4], vexRT[Ch2]);
			}
			else
			{
				steerDrive(vexRT[Ch4], vexRT[Ch3]);
			}
		}
	}
}

//Work on//
task Shooter()
{}

/*Work on//
//Dictated Robot Functions
//allow creation of at least 4 structs ()
//button triggers
//state machine? sensors?*/
task Autonomous()
{}

task main()
{
	StartTask(DriveControl);
	//StartTask(Shooter);
	//StartTask(Autonomous);
	while(true)
	{
	}
}
