#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro1,          sensorGyro)
#pragma config(Sensor, dgtl1,  liftLimit,      sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           DFR,           tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           DBR,           tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port4,           DFL,           tmotorVex393, openLoop)
#pragma config(Motor,  port5,           DBL,           tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port6,           rLift1,        tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           rLift2,        tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           lLift1,        tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port9,           lLift2,        tmotorVex393, openLoop, encoder, encoderPort, I2C_6, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int error = 30;	//define the error

const float DUTY = 0.5;
const int INTERVAL = 800;
const int GROUND = 0; //5D
const int SKYRISE_DISPENSER = 300; //8L
const int LOW_GOAL = 600; //8D
const int MID_GOAL = 900; //8R
const int HIGH_GOAL = 1200; //8U doesnt
const int MAX_HEIGHT = 1500; //5U
int DESCENT_SPEED = -90;
int *const DESCENT_POINTER = &DESCENT_SPEED;
const int LIFT_SPEED = 100;
const int STOP_SPEED  = 0;






void driveLeft(int a)
{
	motor[DBL] = a;
	motor[DFL] = a;
}

void driveRight(int a)
{
	motor[DBR] = a;
	motor[DFR] = a;
}

void drive_straight(float dist, int speed)
{
	while((nMotorEncoder[DBR] < 360 * dist / (4 * PI) + error) || (nMotorEncoder[DBR] < 360 * dist / (4 * PI) - error))
	{
		driveRight(speed);
		driveLeft(speed);
	}
}

///////////////////////Lift///////////////////////

//function for right lift
void rightLift(int a)
{
	motor[rLift1] = a;
	motor[rLift2] = a;
}
//function for left lift
void leftLift (int a)
{
	motor[lLift1] = a;
	motor[lLift2] = a;
}

//function for lift
void lift(int a)
{
	rightLift(a);
	leftLift(a);
}


//move lift until desired value is reached
void moveLift(int a)
{
	int debug = nMotorEncoder[lLift1];
	if(nMotorEncoder[lLift1] < a - error)
	{
		lift(LIFT_SPEED);
	}
	else if(nMotorEncoder[lLift1] > a + error)
	{
		lift(*DESCENT_POINTER);
	}
	else
	{
		lift(STOP_SPEED);
	}
}

///////////////////////Gyro///////////////////////

void gyroTurn(int degrees10)  //specify the amount of degrees to turn
{
	while((abs(SensorValue[in8]) < degrees10))
	{
		motor[port1] = 63;
		motor[port2] = -63;
	}
}

int presets(bool * const preset, int* const target)
{
	int debug = *preset;
	int debug2 = *target;

	int button5D = vexRT[Btn5DXmtr2];
	int button8L = vexRT[Btn8LXmtr2];
	int button8D = vexRT[Btn8DXmtr2];
	int button8R = vexRT[Btn8RXmtr2];
	int button8U = vexRT[Btn8UXmtr2];
	int button5U = vexRT[Btn5UXmtr2];
	int button6U = vexRT[Btn6UXmtr2];
	int button6D = vexRT[Btn6DXmtr2];


	if((button8U== 1) || (button8D== 1) || (button8L == 1)|| (button8R== 1)
		|| (button5U == 1) || (button5D == 1)&& ((button6U == 0) && (button6D== 0)))
	{
		*preset = true; //enabling the auto control
	}
	else if((button8U== 0) && (button8D== 0) && (button8L== 0)&& (button8R == 0)
		&& (button5U == 0) && (button5D== 0) && ((button6U== 1) || (button6D== 1)))
	{
		*preset = false;	//enabling manual control
	}

	if(*preset == true)
	{

		if((button8U == 0) && (button8D == 1) && (button8R == 0) && (button8L == 0)
			&& (button5U == 0) && (button5D == 0))
		{
			*target = LOW_GOAL;
		}
		else if((button8U == 0) && (button8D == 0) && (button8R == 1) && (button8L == 0)
			&& (button5U == 0) && (button5D == 0))
		{
			*target = MID_GOAL;
		}

		else if((button8U == 1) && (button8D == 0) && (button8R == 0) && (button8L == 0)
			&& (button5U == 0) && (button5D == 0))
		{
			*target = HIGH_GOAL;
		}
		else if((button8U == 0) && (button8D == 0) && (button8R == 0) && (button8L == 0)
			&& (button5U == 0) && (button5D == 1))
		{
			*target = GROUND;
		}
		else if((button8U == 0) && (button8D == 0) && (button8R == 0) && (button8L == 0)
			&& (button5U == 1) && (button5D == 0))
		{
			*target = MAX_HEIGHT;
		}
		else if((button8U == 0) && (button8D == 0) && (button8R == 0) && (button8L == 1)
			&& (button5U == 0) && (button5D == 0))
		{
			*target = SKYRISE_DISPENSER;
		}
		else
		{
		}
		debug = *target;
		moveLift(*target);
	}

	//manual control for lift
	else if(*preset == false)
	{
		if((button6U == 1) && (button6D == 0))
		{
			lift(LIFT_SPEED);
		}
		else if((button6D == 1) && (button6U == 0))
		{
			if(SensorValue(liftLimit) == 0)
			{
				lift(*DESCENT_POINTER);
			}
			else if(SensorValue(liftLimit) == 1)
			{
				lift(STOP_SPEED);
			}
		}
		else
		{
			lift(STOP_SPEED);
		}
	}
	return *target;
}



task main()
{
	int count = 0;
	int target = 0;
	nMotorEncoder[lLift1] = 0;
	bool preset = false;
	while(true)
	{
		if(count <= DUTY*INTERVAL)
		{
			*DESCENT_POINTER = -90;
		}
		else
		{
			*DESCENT_POINTER = 0;
		}

		target = presets(&preset, &target);

		count++;
		if(count > INTERVAL)
		{
			count = 0;
		}
	}
}
